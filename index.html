<!DOCTYPE html>
<html>
<head>
    <title>Live Vehicle Tracker</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Circle marker container */
        .circle-marker div {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid white;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="vehicleSelect">Vehicle: </label>
        <select id="vehicleSelect"><option value="all">All Vehicles</option></select>
    </div>
    <div id="map"></div>

    <script>
        // 1. Firebase Setup
        firebase.initializeApp({ databaseURL: "https://iplant-poc-default-rtdb.firebaseio.com/" });
        const db = firebase.database();

        // 2. Leaflet Map Setup
        const map = L.map('map').setView([-33.9, 18.4], 10);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Containers
        const markers = {};
        const polylines = {};
        const vehicleSelect = document.getElementById('vehicleSelect');

        // Colors for vehicles
        const vehicleColors = {};
        const colorPalette = [
            "#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231",
            "#911eb4", "#46f0f0", "#f032e6", "#bcf60c", "#fabebe",
            "#008080", "#e6beff", "#9a6324", "#fffac8", "#800000",
            "#aaffc3", "#808000", "#ffd8b1", "#000075", "#808080"
        ];
        let colorIndex = 0;

        const getVehicleColor = (vid) => {
            if (!vehicleColors[vid]) {
                vehicleColors[vid] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            }
            return vehicleColors[vid];
        };

        const updateMap = (data) => {
            // Clear old markers & polylines
            Object.values(markers).forEach(m => map.removeLayer(m));
            Object.values(polylines).forEach(p => map.removeLayer(p));
            for (let key in markers) delete markers[key];
            for (let key in polylines) delete polylines[key];

            vehicleSelect.innerHTML = '<option value="all">All Vehicles</option>';
            let boundsArr = [];

            for (let vid in data) {
                vehicleSelect.insertAdjacentHTML('beforeend',
                    `<option value="${vid}">${vid}</option>`);

                // Sort all points by timestamp (oldest → newest)
                const sortedPoints = Object.values(data[vid])
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                if (!sortedPoints.length) continue;

                if (vehicleSelect.value !== 'all' && vehicleSelect.value !== vid) continue;

                const points = sortedPoints.map(p => [p.lat, p.lon]);
                const vehicleColor = getVehicleColor(vid);

                // Add a marker for every point
                sortedPoints.forEach((p, idx) => {
                    const latlng = [p.lat, p.lon];

                    // Format timestamp nicely
                    let formattedTime = p.timestamp;
                    try {
                        const d = new Date(p.timestamp);
                        formattedTime = d.toLocaleString("en-GB", {
                            day: "2-digit",
                            month: "short",
                            year: "numeric",
                            hour: "2-digit",
                            minute: "2-digit"
                        });
                    } catch (e) {
                        console.warn("Invalid timestamp:", p.timestamp);
                    }

                    // Choose icon: last = pin, others = colored dot
                    const markerIcon = (idx === sortedPoints.length - 1)
                        ? L.icon({
                            iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34]
                        })
                        : L.divIcon({
                            className: "circle-marker",
                            html: `<div style="background:${vehicleColor}"></div>`
                        });

                    const marker = L.marker(latlng, { icon: markerIcon }).addTo(map)
                        .bindPopup(`<b>${vid}</b><br>Status: ${p.status}<br>Time: ${formattedTime}`)
                        .bindTooltip(`${vid}`, { permanent: false, direction: 'top' });

                    markers[`${vid}_${idx}`] = marker;
                    boundsArr.push(latlng);
                });

                // Add polyline for the path (chronological) with vehicle's color
                const path = L.polyline(points, { color: vehicleColor }).addTo(map);
                polylines[vid] = path;
            }

            // Fit bounds if we have data
           // if (boundsArr.length > 0) {
           //     const bounds = L.latLngBounds(boundsArr);
           //     map.whenReady(() => map.fitBounds(bounds, { padding: [20, 20] }));
           // }
        };

        // 3. Data Listener
        db.ref('vehicles').on('value', snapshot => {
            const data = snapshot.val();
            if (!data) return;
            updateMap(data);
        });

        // 4. Filter handler
        vehicleSelect.addEventListener('change', () =>
            db.ref('vehicles').once('value').then(snap => updateMap(snap.val()))
        );
    </script>
</body>
</html>

